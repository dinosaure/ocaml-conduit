open Conduit_lwt_unix
open Lwt.Infix

let ( >>? ) x f =
  x >>= function Ok x -> f x | Error _ as err -> Lwt.return err

let reword_error f = function Ok _ as v -> v | Error err -> Error (f err)

let failwith fmt = Format.kasprintf (fun err -> raise (Failure err)) fmt

type ('edn, 'flow) endpoint = {
  context : Ssl.context;
  endpoint : 'edn;
  verify :
    Ssl.context -> 'flow -> (Lwt_ssl.socket, [ `Verify of string ]) result Lwt.t;
}

let endpoint ~file_descr ~context ?verify endpoint =
  let verify =
    match verify with
    | Some verify -> verify
    | None ->
        let verify ctx flow =
          let file_descr = file_descr flow in
          Lwt_ssl.ssl_connect file_descr ctx >>= fun v -> Lwt.return_ok v in
        verify in
  { context; endpoint; verify }

module Protocol (C : PROTOCOL) = struct
  type input = Cstruct.t

  type output = Cstruct.t

  type +'a io = 'a Lwt.t

  type error = [ `Closed | `Flow of C.error | `Verify of string ]

  let pp_error ppf = function
    | `Flow err -> C.pp_error ppf err
    | `Verify err -> Fmt.pf ppf "%s" err
    | `Closed -> Fmt.string ppf "Closed"

  type t = Lwt_ssl.socket

  type nonrec endpoint = (C.endpoint, C.t) endpoint

  let pp_endpoint ppf e = C.pp_endpoint ppf e.endpoint

  type flow += Flow of { endpoint : endpoint; flow : t }

  let connect { context; endpoint; verify } =
    C.connect endpoint >|= reword_error (fun err -> `Flow err) >>? fun flow ->
    verify context flow >>= function
    | Ok _ as v -> Lwt.return v
    | Error (`Verify _ as err) -> Lwt.return (Error err)

  let recv socket raw =
    let { Cstruct.buffer; off; len } = raw in
    Lwt_ssl.read_bytes socket buffer off len >>= function
    | 0 -> Lwt.return_ok `End_of_flow
    | len -> Lwt.return_ok (`Len len)

  let send socket raw =
    let { Cstruct.buffer; off; len } = raw in
    Lwt_ssl.write_bytes socket buffer off len >>= fun len -> Lwt.return_ok len

  let close socket =
    (* FIXME(samoht): check double close semantics. *)
    Lwt_ssl.ssl_shutdown socket >>= fun () ->
    Lwt_ssl.close socket >>= fun () -> Lwt.return_ok ()
end

let protocol :
    type a b. (a, b) protocol -> ((a, b) endpoint, Lwt_ssl.socket) protocol =
 fun t ->
  let (module C) = protocol_impl t in
  let module P = Protocol (C) in
  let name = Fmt.strf "%s + ssl" (protocol_name t) in
  protocol name (module P)

type 'a ssl_server = {
  server : 'a;
  context : Ssl.context;
  mutable closed : bool;
}

module Service (Service : sig
  include SERVICE

  val file_descr : flow -> Lwt_unix.file_descr
end) =
struct
  type +'a io = 'a Lwt.t

  type config = Ssl.context * Service.config

  type t = Service.t ssl_server

  type flow = Lwt_ssl.socket

  type error = [ `Closed | `Service of Service.error ]

  let pp_error ppf = function
    | `Service err -> Service.pp_error ppf err
    | `Closed -> Fmt.string ppf "Closed"

  let init (context, edn) =
    Service.init edn >|= reword_error (fun err -> `Service err)
    >>? fun server -> Lwt.return_ok { server; context; closed = false }

  let accept { server; context; closed } =
    if closed
    then Lwt.return (Error `Closed)
    else
      Service.accept server >|= reword_error (fun err -> `Service err)
      >>? fun flow ->
      let accept () = Lwt_ssl.ssl_accept (Service.file_descr flow) context in
      let process socket = Lwt.return_ok socket in
      let error exn =
        Lwt_unix.close (Service.file_descr flow) >>= fun () -> Lwt.fail exn
      in
      Lwt.try_bind accept process error

  let close t =
    if t.closed
    then Lwt.return (Ok ())
    else (
      t.closed <- true ;
      Service.close t.server >|= reword_error (fun err -> `Service err))
end

let service :
    type a b c.
    file_descr:(b -> Lwt_unix.file_descr) ->
    (a, b, c) service ->
    (Ssl.context * a, Lwt_ssl.socket, c ssl_server) service =
 fun ~file_descr t ->
  let (module S) = service_impl t in
  let module M = Service (struct
    include S

    let file_descr = file_descr
  end) in
  let name = Fmt.strf "%s + ssl" (service_name t) in
  service name (module M)

module TCP = struct
  let resolv_conf ~port ~context ?verify domain_name =
    let file_descr = Conduit_lwt_unix_tcp.Protocol.file_descr in
    Conduit_lwt_unix_tcp.resolv_conf ~port domain_name >|= function
    | Some edn -> Some (endpoint ~context ~file_descr ?verify edn)
    | None -> None

  open Conduit_lwt_unix_tcp

  type verify =
    Ssl.context ->
    Protocol.t ->
    (Lwt_ssl.socket, [ `Verify of string ]) result Lwt.t

  let protocol t = protocol t

  let service protocol = service ~file_descr:Protocol.file_descr protocol
end
